---
layout:     post                    # 使用的布局（不需要改）
title:      简单理解双亲委派模型            # 标题 
subtitle:   简单理解双亲委派模型            #副标题
date:       2020-01-20             # 时间
author:     ListJ                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - java
    - 面试
    - jvm
---


面试被问及双亲委派模型，虽然对双亲委派模型有大致的了解，但是还是被问到一脸懵逼，所以回去又学习了下双亲委派模型的基本概念、实现原理等

## 基本概念
### 定义
双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。

### 双亲委派模型的工作过程

 - 如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。
 - 每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。
   
 - 只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。

> 面试被问到“双亲”这个词，当时对“双亲”这个词很困惑。后来了解到“双亲”只是“parents”的直译，实际上并不表示汉语中的父母双亲也就是说不单单指的是两个父类加载器，而是一代一代很多parent，即parents。

### 作用
对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：类随着它的类加载器一起具备了一种带有优先级的层次关系。
例如类`java.lang.Object`，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对`java.lang.Object`的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。
相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为`java.lang.Object`的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。
## 结构
### 系统提供的类加载器
在双亲委派模型的定义中提到了“启动类加载器”。包括启动类加载器，绝大部分Java程序都会使用到以下3种系统提供的类加载器：

 

 - **启动类加载器（Bootstrap ClassLoader）**

负责将存放在`＜JAVA_HOME＞/lib`目录中的，或者被`-Xbootclasspath`参数所指定的路径中的，并且是虚拟机按照文件名识别的（如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。
启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。

> JDK中的常用类大都由启动类加载器加载，如java.lang.String、java.util.List等。需要特别说明的是，启动类Main
> class也由启动类加载器加载。

 - **扩展类加载器（Extension ClassLoader）**

由`sun.misc.Launcher$ExtClassLoader`实现。
负责加载`＜JAVA_HOME＞/lib/ext`目录中的，或者被`java.ext.dirs`系统变量所指定的路径中的所有类库。
开发者可以直接使用扩展类加载器。



- **应用程序类加载器（Application ClassLoader）**

由`sun.misc.Launcher$AppClassLoader`实现。由于这个类加载器是`ClassLoader.getSystemClassLoader()`方法的返回值，所以一般也称它为系统类加载器。
它负责加载用户类路径`ClassPath`上所指定的类库，开发者可以直接使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。

> 启动类Main class、其他如工程中编写的类、maven引用的类，都会被放置在类路径下。Main
> class由启动类加载器加载，其他类由应用程序类加载器加载。

- **自定义的类加载器**
JVM建议用户将应用程序类加载器作为自定义类加载器的父类加载器。则类加载的双亲委派模型如图：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200114192858654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM5NTk1MzQ5,size_16,color_FFFFFF,t_70)
## 为什么使用双亲委派模型
1.双亲委派模型最大的好处就是让Java类同其类加载器一起具备了一种带优先级的层次关系。这句话可能不好理解，我们举个例子。比如我们要加载`java.lang.Object`类，无论我们用哪个类加载器去加载Object类，这个加载请求最终都会委托给`Bootstrap ClassLoader`，这样就保证了所有加载器加载的Object类都是同一个类。如果没有双亲委派模型，完全可能搞出多个不同的Object类。
2.自上而下每个类加载器都会尽力加载.


